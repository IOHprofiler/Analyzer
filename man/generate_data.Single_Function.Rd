% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/DataSetList.R
\name{generate_data.Single_Function}
\alias{generate_data.Single_Function}
\title{#' Get the ERT-values for all DataSets in a DataSetList at certain targets
#'
#' @param dsList The DataSetLsit
#' @param aggr_on Whether to aggregate on 'funcId' or 'DIM'.
#' @param targets Predifined target function-values. Should be one for each function/dimension
#' @param maximize Whether the DataSetList is from a maximization or minimization problem
#'
#' @return A data.table containing ERT-values
#' @export
#' @examples
#' max_ERTs(dsl)
max_ERTs <-
  function(dsList,
           aggr_on = 'funcId',
           targets = NULL,
           maximize = T)
    UseMethod("max_ERTs", dsList)}
\usage{
generate_data.Single_Function(dsList, start = NULL, stop = NULL,
  scale_log = F, which = "by_RT", include_opts = F)
}
\arguments{
\item{dsList}{The DataSetList object}

\item{start}{Optional start value (Runtime or target value)}

\item{stop}{Optional end value (Runtime or target value)}

\item{scale_log}{Wheterh to use logarithmic scaling or not}

\item{which}{Whether to use a fixed-target 'by_RT' perspective or fixed-budget 'by_FV'}

\item{include_opts}{Whether or not to also include the best value hit by each algorithm to
the generated datapoints}
}
\description{
#TODO: rename this function! this function needs to be rewritten
#' @rdname max_ERTs
#' @export
max_ERTs.DataSetList <-
  function(dsList,
           aggr_on = 'funcId',
           targets = NULL,
           maximize = T) {
    N <- length(get_algId(dsList))
    
    aggr_attr <-
      if (aggr_on == 'funcId')
        get_funcId(dsList)
    else
      get_dim(dsList)
    if (!is.null(targets) &&
        length(targets) != length(aggr_attr))
      targets <- NULL
    
    second_aggr <-
      if (aggr_on == 'funcId')
        get_dim(dsList)
    else
      get_funcId(dsList)
    if (length(second_aggr) > 1)
      return(NULL)
    
    erts <- seq(0, 0, length.out = length(get_algId(dsList)))
    names(erts) <- get_algId(dsList)
    
    for (j in seq_along(aggr_attr)) {
      dsList_filetered <-
        if (aggr_on == 'funcId')
          subset(dsList, funcId == aggr_attr[[j]])
      else
        subset(dsList, DIM == aggr_attr[[j]])
      
      if (is.null(targets)) {
        Fall <- get_funvals(dsList_filetered)
        Fval <- ifelse(maximize, max(Fall), min(Fall))
      }
      else
        Fval <- targets[[j]]
      summary <- get_RT_summary(dsList_filetered, ftarget = Fval)
      ert <- summary$ERT
      names(ert) <- summary$algId
      erts <- rbind(erts, ert[get_algId(dsList)])
    }
    return(erts[-1, ])
}
}
\details{
#' Get the expected function-values for all DataSets in a DataSetList at certain runtimes
#'
#' @param dsList The DataSetLsit
#' @param aggr_on Whether to aggregate on 'funcId' or 'DIM'.
#' @param runtimes Predifined target runtimes-values. Should be one for each function/dimension
#'
#' @return A data.table containing expected fucntion-values
#' @export
#' @examples
#' mean_FVs(dsl)
mean_FVs <-
  function(dsList,
           aggr_on = 'funcId',
           runtimes = NULL)
    UseMethod("mean_FVs", dsList)

#' @rdname mean_FVs
#' @export
mean_FVs.DataSetList <-
  function(dsList,
           aggr_on = 'funcId',
           runtimes = NULL) {
    N <- length(get_algId(dsList))
    
    aggr_attr <-
      if (aggr_on == 'funcId')
        get_funcId(dsList)
    else
      get_dim(dsList)
    if (!is.null(runtimes) &&
        length(runtimes) != length(aggr_attr))
      targets <- NULL
    
    second_aggr <-
      if (aggr_on == 'funcId')
        get_dim(dsList)
    else
      get_funcId(dsList)
    if (length(second_aggr) > 1)
      return(NULL)
    
    erts <- seq(0, 0, length.out = length(get_algId(dsList)))
    names(erts) <- get_algId(dsList)
    
    for (j in seq_along(aggr_attr)) {
      dsList_filetered <-
        if (aggr_on == 'funcId')
          subset(dsList, funcId == aggr_attr[[j]])
      else
        subset(dsList, DIM == aggr_attr[[j]])
      
      if (is.null(runtimes)) {
        RTall <- get_runtimes(dsList_filetered)
        RTval <- max(RTall)
      }
      else
        RTval <- runtimes[[j]]
      summary <- get_FV_summary(dsList_filetered, runtime = RTval)
      ert <- summary$mean
      names(ert) <- summary$algId
      erts <- rbind(erts, ert[get_algId(dsList)])
    }
    return(erts[-1, ])
  }
Generate dataframe of a single function/dimension pair

This function generates a dataframe which can be easily plotted using the `plot_general_data`-function
}
